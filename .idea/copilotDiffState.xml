<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ATTACHMENT_IMPLEMENTATION_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ATTACHMENT_IMPLEMENTATION_SUMMARY.md" />
              <option name="updatedContent" value="# Email Attachment Implementation - Backend&#10;&#10;## Overview&#10;The backend now properly receives and processes file attachments sent from the Angular frontend using multipart/form-data.&#10;&#10;---&#10;&#10;## Architecture&#10;&#10;### 1. **MailController** - Entry Point&#10;```java&#10;@PostMapping(&quot;/send-with-attachments&quot;)&#10;public Map&lt;String, String&gt; sendMail(&#10;    @RequestPart(&quot;email&quot;) ComposeEmailDTO composeEmailDTO,&#10;    @RequestPart(value = &quot;attachments&quot;, required = false) List&lt;MultipartFile&gt; attachments&#10;) throws IOException&#10;```&#10;&#10;**Key Points:**&#10;- **Endpoint:** `POST /api/mail/send-with-attachments`&#10;- **Content-Type:** `multipart/form-data`&#10;- **Parameters:**&#10;  - `email` (required): JSON object with email details (sender, receivers, subject, body, priority)&#10;  - `attachments` (optional): Array of files&#10;&#10;**Request Structure from Frontend:**&#10;```typescript&#10;const formData = new FormData();&#10;&#10;// Part 1: Email metadata as JSON&#10;const emailBlob = new Blob([JSON.stringify(emailData)], { type: 'application/json' });&#10;formData.append('email', emailBlob);&#10;&#10;// Part 2: Attach files&#10;files.forEach(file =&gt; formData.append('attachments', file, file.name));&#10;```&#10;&#10;---&#10;&#10;### 2. **MailService** - Business Logic Layer&#10;```java&#10;public void sendWithAttachments(ComposeEmailDTO composeEmailDTO, List&lt;MultipartFile&gt; attachments) &#10;    throws IOException {&#10;    sendCommand.executeWithAttachments(composeEmailDTO, attachments);&#10;}&#10;```&#10;&#10;**Responsibilities:**&#10;- Delegates to `SendCommand` (Command Pattern)&#10;- Provides clean interface for controller&#10;&#10;---&#10;&#10;### 3. **SendCommand** - Email Sending Logic&#10;```java&#10;@Transactional&#10;public void executeWithAttachments(ComposeEmailDTO dto, List&lt;MultipartFile&gt; attachments) &#10;    throws IOException&#10;```&#10;&#10;**Process Flow:**&#10;&#10;#### Step 1: Create Sent Copy&#10;```java&#10;Mail sentCopy = Mail.builder()&#10;    .sender(dto.getSender())&#10;    .senderRel(senderUser)&#10;    .receiver(String.join(&quot;,&quot;, dto.getReceivers()))&#10;    .subject(dto.getSubject())&#10;    .body(dto.getBody())&#10;    .priority(dto.getPriority())&#10;    .folderName(&quot;SENT&quot;)&#10;    .isRead(true)&#10;    .timestamp(LocalDateTime.now())&#10;    .build();&#10;mailRepository.save(sentCopy);&#10;```&#10;&#10;#### Step 2: Save Attachments for Sent Copy&#10;```java&#10;if (attachments != null &amp;&amp; !attachments.isEmpty()) {&#10;    for (MultipartFile file : attachments) {&#10;        attachmentService.saveAttachment(file, sentCopy);&#10;    }&#10;}&#10;```&#10;&#10;#### Step 3: Create Inbox Copy for Each Receiver&#10;```java&#10;for (String receiverEmail : receivers) {&#10;    Mail inboxCopy = Mail.builder()&#10;        .sender(dto.getSender())&#10;        .receiver(receiverEmail)&#10;        .folderName(&quot;INBOX&quot;)&#10;        .isRead(false)&#10;        // ... other fields&#10;        .build();&#10;    mailRepository.save(inboxCopy);&#10;    &#10;    // Copy attachments for each receiver&#10;    if (attachments != null &amp;&amp; !attachments.isEmpty()) {&#10;        for (MultipartFile file : attachments) {&#10;            attachmentService.saveAttachment(file, inboxCopy);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**Key Features:**&#10;- **@Transactional**: All-or-nothing operation&#10;- **Separate Mail Objects**: Each email copy (sent + inbox per receiver) is a separate entity&#10;- **Attachment Duplication**: Each mail copy gets its own set of attachment records&#10;- **Validation**: Checks that receivers exist in the system&#10;&#10;---&#10;&#10;### 4. **AttachmentService** - File Management&#10;```java&#10;public Attachment saveAttachment(MultipartFile file, Mail mail) throws IOException&#10;```&#10;&#10;**Process:**&#10;&#10;1. **Generate Unique Filename**&#10;   ```java&#10;   String uniqueFileName = UUID.randomUUID() + &quot;_&quot; + file.getOriginalFilename();&#10;   ```&#10;&#10;2. **Create Directory Structure**&#10;   ```java&#10;   String filePath = &quot;attachments/&quot; + mail.getMailId() + &quot;/&quot; + uniqueFileName;&#10;   Files.createDirectories(path.getParent());&#10;   ```&#10;&#10;3. **Save File to Disk**&#10;   ```java&#10;   Files.write(path, file.getBytes());&#10;   ```&#10;&#10;4. **Create Database Record**&#10;   ```java&#10;   Attachment attachment = Attachment.builder()&#10;       .fileName(file.getOriginalFilename())&#10;       .contentType(file.getContentType())&#10;       .fileSize(file.getSize())&#10;       .filePath(filePath)&#10;       .uploadDate(LocalDateTime.now())&#10;       .mail(mail)&#10;       .build();&#10;   return attachmentRepository.save(attachment);&#10;   ```&#10;&#10;**File Storage Structure:**&#10;```&#10;attachments/&#10;├── {mail_id_1}/&#10;│   ├── {uuid}_filename1.pdf&#10;│   └── {uuid}_filename2.jpg&#10;├── {mail_id_2}/&#10;│   └── {uuid}_filename3.docx&#10;```&#10;&#10;---&#10;&#10;## Data Flow Diagram&#10;&#10;```&#10;┌─────────────┐&#10;│   Frontend  │&#10;│  (Angular)  │&#10;└─────┬───────┘&#10;      │ FormData with email JSON + files&#10;      │&#10;      ▼&#10;┌─────────────────────────────────────┐&#10;│  MailController                     │&#10;│  @RequestPart(&quot;email&quot;)              │&#10;│  @RequestPart(&quot;attachments&quot;)        │&#10;└─────┬───────────────────────────────┘&#10;      │&#10;      ▼&#10;┌─────────────────────────────────────┐&#10;│  MailService                        │&#10;│  sendWithAttachments()              │&#10;└─────┬───────────────────────────────┘&#10;      │&#10;      ▼&#10;┌─────────────────────────────────────┐&#10;│  SendCommand                        │&#10;│  executeWithAttachments()           │&#10;│  ┌────────────────────────────────┐ │&#10;│  │ 1. Create SENT copy           │ │&#10;│  │ 2. Save attachments           │ │&#10;│  │ 3. Create INBOX copies        │ │&#10;│  │ 4. Copy attachments to each   │ │&#10;│  └────────────────────────────────┘ │&#10;└─────┬───────────────────────────────┘&#10;      │&#10;      ▼&#10;┌─────────────────────────────────────┐&#10;│  AttachmentService                  │&#10;│  saveAttachment()                   │&#10;│  ┌────────────────────────────────┐ │&#10;│  │ 1. Generate unique filename   │ │&#10;│  │ 2. Create directory           │ │&#10;│  │ 3. Save file to disk          │ │&#10;│  │ 4. Save metadata to database  │ │&#10;│  └────────────────────────────────┘ │&#10;└─────────────────────────────────────┘&#10;      │&#10;      ▼&#10;┌─────────────────────────────────────┐&#10;│  File System + Database             │&#10;│  - Physical files in attachments/  │&#10;│  - Attachment records in DB         │&#10;└─────────────────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;## Entity Relationships&#10;&#10;```&#10;┌────────────┐          ┌─────────────────┐&#10;│    User    │◄─────────┤      Mail       │&#10;│            │          │                 │&#10;│  - email   │          │  - mailId       │&#10;│  - name    │          │  - sender       │&#10;└────────────┘          │  - receiver     │&#10;                        │  - subject      │&#10;                        │  - body         │&#10;                        │  - folderName   │&#10;                        │  - timestamp    │&#10;                        └────────┬────────┘&#10;                                 │ 1:N&#10;                                 ▼&#10;                        ┌─────────────────┐&#10;                        │   Attachment    │&#10;                        │                 │&#10;                        │  - id           │&#10;                        │  - fileName     │&#10;                        │  - contentType  │&#10;                        │  - fileSize     │&#10;                        │  - filePath     │&#10;                        │  - uploadDate   │&#10;                        │  - mail (FK)    │&#10;                        └─────────────────┘&#10;```&#10;&#10;---&#10;&#10;## Example Usage&#10;&#10;### Frontend Request&#10;```typescript&#10;// Compose email&#10;const emailData = {&#10;  sender: &quot;user@example.com&quot;,&#10;  receivers: [&quot;receiver1@example.com&quot;, &quot;receiver2@example.com&quot;],&#10;  subject: &quot;Project Files&quot;,&#10;  body: &quot;Please find the attached documents.&quot;,&#10;  priority: 1&#10;};&#10;&#10;// Prepare form data&#10;const formData = new FormData();&#10;formData.append('email', new Blob([JSON.stringify(emailData)], {type: 'application/json'}));&#10;&#10;// Add files&#10;selectedFiles.forEach(file =&gt; {&#10;  formData.append('attachments', file, file.name);&#10;});&#10;&#10;// Send request&#10;http.post('http://localhost:8080/api/mail/send-with-attachments', formData)&#10;  .subscribe(response =&gt; console.log('Email sent!'));&#10;```&#10;&#10;### Backend Response&#10;```json&#10;{&#10;  &quot;message&quot;: &quot;Email sent successfully&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;## Database Results&#10;&#10;After sending one email with 2 attachments to 2 receivers:&#10;&#10;### Mail Table (3 records)&#10;| mailId | sender | receiver | folderName | subject |&#10;|--------|--------|----------|------------|---------|&#10;| 1 | user@example.com | receiver1@example.com,receiver2@example.com | SENT | Project Files |&#10;| 2 | user@example.com | receiver1@example.com | INBOX | Project Files |&#10;| 3 | user@example.com | receiver2@example.com | INBOX | Project Files |&#10;&#10;### Attachment Table (6 records)&#10;| id | fileName | filePath | mail_id |&#10;|----|----------|----------|---------|&#10;| 1 | file1.pdf | attachments/1/uuid1_file1.pdf | 1 |&#10;| 2 | file2.jpg | attachments/1/uuid2_file2.jpg | 1 |&#10;| 3 | file1.pdf | attachments/2/uuid3_file1.pdf | 2 |&#10;| 4 | file2.jpg | attachments/2/uuid4_file2.jpg | 2 |&#10;| 5 | file1.pdf | attachments/3/uuid5_file1.pdf | 3 |&#10;| 6 | file2.jpg | attachments/3/uuid6_file2.jpg | 3 |&#10;&#10;---&#10;&#10;## Error Handling&#10;&#10;1. **Missing Sender:** `RuntimeException: &quot;Sender email not found&quot;`&#10;2. **Invalid Receiver:** `RuntimeException: &quot;the following receivers were not found: {emails}&quot;`&#10;3. **File I/O Error:** `IOException` propagated to controller&#10;4. **Transaction Rollback:** If any step fails, entire operation is rolled back (@Transactional)&#10;&#10;---&#10;&#10;## API Testing with Postman/cURL&#10;&#10;```bash&#10;curl -X POST http://localhost:8080/api/mail/send-with-attachments \&#10;  -F 'email={&quot;sender&quot;:&quot;user@example.com&quot;,&quot;receivers&quot;:[&quot;receiver@example.com&quot;],&quot;subject&quot;:&quot;Test&quot;,&quot;body&quot;:&quot;Hello&quot;,&quot;priority&quot;:1};type=application/json' \&#10;  -F 'attachments=@/path/to/file1.pdf' \&#10;  -F 'attachments=@/path/to/file2.jpg'&#10;```&#10;&#10;---&#10;&#10;## Key Implementation Benefits&#10;&#10;1. ✅ **Standard HTTP Multipart**: Uses industry-standard multipart/form-data&#10;2. ✅ **Efficient File Handling**: Files stored once on disk, metadata in DB&#10;3. ✅ **Transactional Safety**: All-or-nothing email sending&#10;4. ✅ **Scalable**: Files organized by mail ID&#10;5. ✅ **Optional Attachments**: Backend handles emails with or without attachments&#10;6. ✅ **Multiple Receivers**: Each receiver gets their own copy with attachments&#10;7. ✅ **File Metadata**: Tracks original filename, size, type, and upload date&#10;&#10;---&#10;&#10;## Future Enhancements&#10;&#10;- [ ] Add attachment size validation&#10;- [ ] Implement file type restrictions&#10;- [ ] Add virus scanning&#10;- [ ] Implement attachment compression&#10;- [ ] Add thumbnail generation for images&#10;- [ ] Implement attachment search/indexing&#10;- [ ] Add download tracking&#10;- [ ] Implement shared attachments (dedupe storage)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/GETMAIL_COMMAND_PATTERN.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/GETMAIL_COMMAND_PATTERN.md" />
              <option name="updatedContent" value="# GetMailCommand - Command Pattern Implementation&#10;&#10;## Overview&#10;Successfully refactored `getMailWithAttachments()` to follow the Command Pattern, matching the existing architecture used by `SendCommand` and `DraftCommand`.&#10;&#10;---&#10;&#10;## What Was Changed&#10;&#10;### Before (Direct Implementation)&#10;```java&#10;@Service&#10;@RequiredArgsConstructor&#10;public class MailService {&#10;    private final MailRepository mailRepository;&#10;    private final AttachmentService attachmentService;&#10;    &#10;    public EmailViewDto getMailWithAttachments(Long mailId) {&#10;        // Logic directly in service&#10;        Mail mail = mailRepository.findById(mailId)...&#10;        List&lt;AttachmentDTO&gt; attachments = attachmentService.getAttachmentsWithData(mailId);&#10;        return EmailViewDto.builder()...&#10;    }&#10;}&#10;```&#10;&#10;### After (Command Pattern)&#10;```java&#10;@Service&#10;@RequiredArgsConstructor&#10;public class MailService {&#10;    private final GetMailCommand getMailCommand;&#10;    &#10;    public EmailViewDto getMailWithAttachments(Long mailId) {&#10;        return getMailCommand.execute(mailId);&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## New Command: GetMailCommand&#10;&#10;### Location&#10;```&#10;mail-server/src/main/java/eg/edu/alexu/cse/mail_server/Service/command/GetMailCommand.java&#10;```&#10;&#10;### Implementation&#10;```java&#10;@Component&#10;@RequiredArgsConstructor&#10;public class GetMailCommand {&#10;    private final MailRepository mailRepository;&#10;    private final AttachmentService attachmentService;&#10;&#10;    /**&#10;     * Execute the command to get mail with attachments.&#10;     * &#10;     * @param mailId the ID of the mail to retrieve&#10;     * @return EmailViewDto with attachments and Base64 file data&#10;     * @throws RuntimeException if mail is not found&#10;     * @throws IOException if file reading fails&#10;     */&#10;    public EmailViewDto execute(Long mailId) throws IOException {&#10;        // 1. Get mail entity from database&#10;        Mail mail = mailRepository.findById(mailId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Mail not found&quot;));&#10;&#10;        // 2. Get all attachments with file data&#10;        List&lt;AttachmentDTO&gt; attachments = &#10;            attachmentService.getAttachmentsWithData(mailId);&#10;&#10;        // 3. Build and return complete DTO&#10;        return EmailViewDto.builder()&#10;                .id(mail.getMailId())&#10;                .sender(mail.getSender())&#10;                .subject(mail.getSubject())&#10;                .body(mail.getBody())&#10;                .timestamp(mail.getTimestamp())&#10;                .priority(mail.getPriority())&#10;                .isRead(mail.isRead())&#10;                .attachments(attachments)&#10;                .build();&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Benefits of Command Pattern&#10;&#10;### 1. **Consistency**&#10;All mail operations now follow the same pattern:&#10;```java&#10;public class MailService {&#10;    private final SendCommand sendCommand;&#10;    private final DraftCommand draftCommand;&#10;    private final GetMailCommand getMailCommand;  // ✅ Same pattern&#10;    &#10;    public void send(ComposeEmailDTO dto) {&#10;        sendCommand.execute(dto);&#10;    }&#10;    &#10;    public void draft(ComposeEmailDTO dto) {&#10;        draftCommand.execute(dto);&#10;    }&#10;    &#10;    public EmailViewDto getMailWithAttachments(Long mailId) {&#10;        getMailCommand.execute(mailId);  // ✅ Same pattern&#10;    }&#10;}&#10;```&#10;&#10;### 2. **Separation of Concerns**&#10;- `MailService` → Coordinates commands&#10;- `GetMailCommand` → Encapsulates mail retrieval logic&#10;- `AttachmentService` → Handles attachment operations&#10;&#10;### 3. **Testability**&#10;```java&#10;// Easy to mock and test independently&#10;@Test&#10;void testGetMailCommand() {&#10;    GetMailCommand command = new GetMailCommand(&#10;        mockMailRepository, &#10;        mockAttachmentService&#10;    );&#10;    &#10;    EmailViewDto result = command.execute(123L);&#10;    &#10;    verify(mockMailRepository).findById(123L);&#10;    verify(mockAttachmentService).getAttachmentsWithData(123L);&#10;}&#10;```&#10;&#10;### 4. **Extensibility**&#10;Easy to add new commands:&#10;```java&#10;// Future: GetMailsByFolderCommand&#10;// Future: SearchMailsCommand&#10;// Future: MoveMailToFolderCommand&#10;```&#10;&#10;---&#10;&#10;## Architecture&#10;&#10;```&#10;┌─────────────────────────────────────────────────────┐&#10;│              MailController                         │&#10;│  GET /api/mail/{mailId}                             │&#10;└────────────────────┬────────────────────────────────┘&#10;                     ↓&#10;┌─────────────────────────────────────────────────────┐&#10;│              MailService                            │&#10;│  - sendCommand                                      │&#10;│  - draftCommand                                     │&#10;│  - getMailCommand  ← Delegates to command           │&#10;└────────────────────┬────────────────────────────────┘&#10;                     ↓&#10;┌─────────────────────────────────────────────────────┐&#10;│           GetMailCommand                            │&#10;│  execute(mailId) {                                  │&#10;│    1. Load mail from repository                     │&#10;│    2. Load attachments with data                    │&#10;│    3. Build EmailViewDto                            │&#10;│  }                                                  │&#10;└────────────────────┬────────────────────────────────┘&#10;                     ↓&#10;┌──────────────────────────┬──────────────────────────┐&#10;│    MailRepository        │   AttachmentService      │&#10;│    findById()            │   getAttachmentsWithData()│&#10;└──────────────────────────┴──────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;## Command Pattern Structure&#10;&#10;### Interface (Optional for Future)&#10;```java&#10;// Could create a generic command interface&#10;public interface Command&lt;T, R&gt; {&#10;    R execute(T input);&#10;}&#10;&#10;// GetMailCommand implements Command&lt;Long, EmailViewDto&gt;&#10;// SendCommand implements Command&lt;ComposeEmailDTO, Void&gt;&#10;```&#10;&#10;### Current Implementation&#10;- Each command is a standalone `@Component`&#10;- Commands have their own `execute()` method&#10;- Service layer delegates to commands&#10;&#10;---&#10;&#10;## Usage&#10;&#10;### In Controller&#10;```java&#10;@GetMapping(&quot;/{mailId}&quot;)&#10;public ResponseEntity&lt;EmailViewDto&gt; getMail(@PathVariable Long mailId) &#10;        throws IOException {&#10;    EmailViewDto mail = mailService.getMailWithAttachments(mailId);&#10;    return ResponseEntity.ok(mail);&#10;}&#10;```&#10;&#10;### Execution Flow&#10;```&#10;Controller → MailService → GetMailCommand → MailRepository + AttachmentService&#10;```&#10;&#10;---&#10;&#10;## Comparison with Other Commands&#10;&#10;| Command | Input | Output | Transactional |&#10;|---------|-------|--------|---------------|&#10;| `SendCommand` | `ComposeEmailDTO` | `void` | ✅ Yes |&#10;| `DraftCommand` | `ComposeEmailDTO` | `void` | ✅ Yes |&#10;| `GetMailCommand` | `Long mailId` | `EmailViewDto` | ❌ No (read-only) |&#10;&#10;---&#10;&#10;## Summary&#10;&#10;✅ **Created**: `GetMailCommand.java`  &#10;✅ **Refactored**: `MailService.java` to use command pattern  &#10;✅ **Consistent**: Matches existing `SendCommand` and `DraftCommand` architecture  &#10;✅ **Clean**: Separates concerns and improves testability  &#10;✅ **Extensible**: Easy to add more commands in the future  &#10;&#10;The implementation now follows the **Command Pattern** consistently across all mail operations! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>